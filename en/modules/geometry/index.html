<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  
  <link rel="shortcut icon" href="../../img/favicon.ico">
  <title>Geometry - FCLib</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700" />

  <link rel="stylesheet" href="../../css/theme.css" />
  <link rel="stylesheet" href="../../css/theme_extra.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" />
  
  <script>
    // Current page data
    var mkdocs_page_name = "Geometry";
    var mkdocs_page_input_path = "modules\\geometry.md";
    var mkdocs_page_url = null;
  </script>
  
  <script src="../../js/jquery-2.1.1.min.js" defer></script>
  <script src="../../js/modernizr-2.8.3.min.js" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
        <a href="../.." class="icon icon-home"> FCLib</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
                <p class="caption"><span class="caption-text">Overview</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../..">Brief Introduction</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../rules/">Some Rules</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">Modules</span></p>
                <ul class="current">
                    <li class="toctree-l1"><a class="reference internal" href="../camera/">Camera</a>
                    </li>
                    <li class="toctree-l1 current"><a class="reference internal current" href="./">Geometry</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#geometryh">Geometry.h</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#geometry2dh">Geometry2d.h</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#pointcloudh">PointCloud.h</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#trianglemeshh">TriangleMesh.h</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#ransach">Ransac.h</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#rgbdframeh">RGBDFrame.h</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#kdtreeh">KDTree.h</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#opencv-not-recommended">OpenCV (Not Recommended)</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#nanoflann">nanoflann</a>
    </li>
        </ul>
    </li>
    </ul>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../odometry/">Odometry</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../lcdetection/">Loop Closure Detection</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../registration/">Point Cloud Registration</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../optimization/">Optimization</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../integration/">Generate Model</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../visualization/">Visualization</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../algorithm/">Some Algorithms</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../tool/">Other Useful Tools</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../examples/">Examples</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">Others</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../changelog/">ChangeLog</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../thanksto/">Acknowledgments</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../about/">About Author</a>
                    </li>
                </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../..">FCLib</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../..">Docs</a> &raquo;</li>
    
      
        
          <li>Modules &raquo;</li>
        
      
    
    <li>Geometry</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h2 id="geometry">Geometry</h2>
<p><em>namespace: geometry</em></p>
<p>The geometry module is a foundation of the entire system. It defines some very basic data structures and implements basic operations and algorithms, including points, transformation matrix, the conversion between Lie groups and Lie algebras (SE(3), se(3)) etc., as well as the definition and implementation of common data structures such as point clouds, triangular mesh and related algorithms.</p>
<h3 id="geometryh">Geometry.h</h3>
<p>In <code>Geometry.h</code>, the first thing you shuold notice is that:</p>
<pre><code class="cpp">typedef float scalar; 
</code></pre>

<p>By default, <code>float</code> is used as the scalar type, so the format of point clouds, matrix, etc. are all single-precision, and the floating-point number precision used by the entire library can be changed here.</p>
<pre><code class="cpp">typedef Vector6 Se3;
typedef Matrix4 SE3;
</code></pre>

<p>Lie group Lie algebras are defined as <code>SE3</code> and <code>Se3</code>, which are four-dimensional square matrix and six-dimensional matrix, respectively, through the function:</p>
<pre><code class="cpp">Matrix4 Se3ToSE3(const Vector6 &amp;input);
Vector6 SE3ToSe3(const Matrix4 &amp;input);
</code></pre>

<p>you can do the conversion. These functions are implemented based on <code>Sophus</code> library(In Open3D, the mutual conversion from a 6-dimensional vector to a 4-dimensional square matrix is completely unchanged for the translation part, but from the mathematical derivation, there is a slight difference between the two, so the <code>Sophus</code> library should be more accurate).
<img alt="" src="../../img/lie.jpg" /></p>
<pre><code class="cpp">struct VoxelGridHasher;
struct PixelGridHasher;
</code></pre>

<p>The above two are hash functions for three-dimensional and two-dimensional integer vectors, and spatial hashing is a very efficient data structure.</p>
<pre><code class="cpp">std::tuple&lt;Point3, double, double&gt; FitPlane(const Point3List &amp; _points);
std::tuple&lt;Vector2, double, double&gt; FitLine(const Point2List &amp; _points);
</code></pre>

<p>The above functions are used to fit a set of 3D point planes and 2D point lines. For example, in a three-dimensional coordinate system, the parametric equation of a plane is: <span class="arithmatex">\(ax+by+cz+d = 0\)</span>, where <span class="arithmatex">\(n=\{ a, b, c\)^T\)</span> is the normal vector of the plane. The return value type of the above function is <code>std::tuple</code>, where the first term is the normal vector, and the second is <span class="arithmatex">\(d\)</span>. The third one is a ratio of the second largest singular value to the largest singular value (using SVD to fit a plane or a straight line, you can get singular values), which can be used as an indicator of the error between the original points and the fitted plane. If all points are in On the plane, the value is 0. That is, the better the plane fits, the smaller the value.</p>
<p>OPLib use <code>Point3List</code> to denote an array of <code>Eigen::Matrix&lt;geometry::scalar, 3, 1&gt;</code>, similarly, <code>PointXList</code> represents an array of <code>Eigen::Matrix&lt;scalar, Eigen::Dynamic, 1&gt;</code>. Also, with cpp 11, we can give an alias for <code>Eigen::Matrix&lt;geometry::Scalar, T, 1&gt;</code> by:</p>
<pre><code class="cpp">    template &lt;int T&gt;
        using Vector = Eigen::Matrix&lt;scalar, T, 1&gt;;
</code></pre>

<p>So you can use <code>Vector&lt;10&gt;</code> to declare a 10D vector. Therefore, we also use <code>PointList</code> to denote an array of template vector, which means we use <code>PointList&lt;100&gt;</code> as an alias of <code>std::vector&lt;Eigen::Matrix&lt;scalar, 100, 1&gt;, Eigen::aligned_allocator&lt;Eigen::Matrix&lt;scalar, 100, 1&gt;&gt;&gt;</code>.  This is much useful.</p>
<p>In <code>Geometry.h</code>, some other aliases are also defined. These aliases are defined for easy-understanding. Some basic knowledges of Feature Matching, etc. is needed to understand the meanings.</p>
<h3 id="geometry2dh">Geometry2d.h</h3>
<p><code>Geometry2d.h</code> implements some geometric algorithms on 2d, mainly to calculate some very basic content of geometry. This part is written for <code>DCEL</code> (doubly connected edge list) in <code>Algorithm</code>. The main functions in this part are:</p>
<pre><code class="cpp">//Check if a point is inside a convex polygon
int CheckPointInConvexPoly(const geometry::Point2List &amp;points, const Point2 &amp;p);
//Calculate the area of a convex polygon
float ComputeAreaConvexPoly(const Point2List &amp;points);
</code></pre>

<h3 id="pointcloudh">PointCloud.h</h3>
<p><code>PointCloud.h</code> implements some point cloud-related data structures and algorithms. The point cloud contains points, colors, and normals (the latter two are optional). The related algorithms include point cloud downsampling, normal vector estimation, and so on. Some basic member functions are listed below:</p>
<pre><code class="cpp">//Read PCD from PLY file
void LoadFromPLY(const std::string &amp;filename);
//Read PCD from OBJ file
void LoadFromOBJ(const std::string &amp;filename);
//Read PCD from color and depth
void LoadFromRGBD(const cv::Mat &amp;rgb, const cv::Mat &amp; depth, const camera::PinholeCamera &amp;camera );
void LoadFromRGBD(const RGBDFrame &amp;rbgd, const camera::PinholeCamera &amp;camera );
//Estimate the normal vector by fitting a plane to the surrounding points of a certain point. 
//`radius` represents the search radius, and `knn` represents the number of fitting points
void EstimateNormals(float radius = 0.1, int knn = 30);
//Transform pcd
void Transform(const TransformationMatrix &amp;T);
//Down sample 
std::shared_ptr&lt;PointCloud&gt; DownSample(double grid_len);
//Write pcd to PLY file
bool WriteToPLY(const std::string &amp;fileName) const;
//Write pcd to OBJ file
bool WriteToOBJ(const std::string &amp;fileName) const;
//Merge this pcd with another one
void MergePCD(const PointCloud &amp; another_pcd);
</code></pre>

<h4 id="trianglemeshh">TriangleMesh.h</h4>
<p>TriangleMesh defines the triangular mesh data structures and related algorithms. The biggest difference between a triangular mesh and a point cloud is that there are edges and faces in triangle mesh. In the triangular mesh, each face is a triangle and consists of 3 points. Therefore, there is also a face table in the triangular mesh, which stores the indexes of the 3 points of each triangle. The currently implemented grid does not contain textures.</p>
<pre><code class="cpp">//Read mesh from PLY file
void LoadFromPLY(const std::string &amp;filename);
// Read Mesh from OBJ file
void LoadFromOBJ(const std::string &amp;filename);
/*
Calculating the normal vector, the normal vector of the triangular grid is easier to estimate compared to the normal vector of the pcd.
First of all, the triangular mesh already has a face, and you can directly find the plane based on the three points to get the normal vector of the face.
Then, we only need to perform a weighted average of the normal vectors of all the faces connected to the point to get the normal vector of a point.
*/
void ComputeNormals(float radius = 0.1, int knn = 30);
//Transform the mesh
void Transform(const TransformationMatrix &amp;T);
//Write mesh to PLY file
bool WriteToPLY(const std::string &amp;fileName) const;
//Write mesh to OBJ file
bool WriteToOBJ(const std::string &amp;fileName) const;
//Simplify mesh with edge collapse based on quadric error
std::shared_ptr&lt;geometry::TriangleMesh&gt; QuadricSimplify(int target_num) const;
//Voxel-based uniform grid simplification, similar to point cloud downsampling
std::shared_ptr&lt;geometry::TriangleMesh&gt; ClusteringSimplify(float grid_len) const;
//Remove fragments whose connected points is less than a threshold
std::shared_ptr&lt;geometry::TriangleMesh&gt; Prune(int min_points) const;
</code></pre>

<p>For details of quadric simplification, refer to:<code>related_paper/quadrics.pdf</code>.</p>
<p>Comparison of simplification: <a href="../../examples/#_2">Simplification</a></p>
<h3 id="ransach">Ransac.h</h3>
<p><code>Ransac.h</code> mainly implements two specific algorithms that use ransac, based on a basic Ransac framework <a href="https://github.com/drsrinathsridhar/GRANSAC">GRANSAC</a>. The advantage of Ransac is that it will randomly extract some points are used to find a certain transformation or model, so that outliers can be largely excluded. For example, when fitting a plane, if you use the <code>FitPlane</code> in <code>Geometry.h</code> to directly fit, then the outlier will have a great impact on the result. And using Ransac can get better results.</p>
<pre><code class="cpp">//Use Ransac to estimate the relative transformation
TransformationMatrix EstimateRigidTransformationRANSAC(const PointCorrespondenceSet &amp;correspondence_set,
    PointCorrespondenceSet &amp; inliers, std::vector&lt;int&gt; &amp;inlier_ids, int max_iteration = 2000, float threshold = 0.1);
//Use Ransac to fit plane
std::tuple&lt;geometry::Point3, double, double&gt; FitPlaneRANSAC(const Point3List &amp;points, 
    Point3List &amp; inliers, std::vector&lt;int&gt; &amp;inlier_ids, int max_iteration = 2000, float threshold = 0.05);
</code></pre>

<p>You can get the inlies and corresponding indices using above function.</p>
<h3 id="rgbdframeh">RGBDFrame.h</h3>
<p><code>RGBDFrame.h</code> defines the RGBDFrame data structure, which integrates the depth map and the color map, and can simplify the calling process. This data structure is mainly used to serve an RGBD SLAM system. It can save some of the extracted features, point cloud and so on, which are needed for tracking. When building an RGBD SLAM, for efficiency these contents do not need to be recalculated. <code>Release()</code> is used to release all saved content.</p>
<h3 id="kdtreeh">KDTree.h</h3>
<p>There are two underlying implementations of KDTree, which are based on OpenCV and nanoflann respectively. You can choose any of the by settingt the pre-defined variable <code>NANO_IMPLAMENTATION</code>.</p>
<h4 id="opencv-not-recommended">OpenCV (Not Recommended)</h4>
<p>The most troublesome part of calling OpenCV's KDTree is the mutual conversion between Eigen and OpenCv, and in fact, <code>geometry::KDTree</code> is to solve this.</p>
<p>The following is a piece of code (from the Internet) that uses kdtree in OpenCV.</p>
<pre><code class="cpp">int main() {
    //Points to build tree
    vector&lt;cv::Point2f&gt; features = { { 1,1 },{ 2, 2},{ 3, 3},{ 4, 4},{ 2, 4} };
    cv::Mat source = cv::Mat(features).reshape(1);
    source.convertTo(source, CV_32F);

    cv::flann::KDTreeIndexParams indexParams(2);
    cv::flann::Index kdtree(source, indexParams); 

    //Parameter
    int queryNum = 3;//knn 
    vector&lt;float&gt; vecQuery(2);//query point
    vector&lt;int&gt; vecIndex(queryNum);//indices of the k nearest points
    vector&lt;float&gt; vecDist(queryNum);//distances
    cv::flann::SearchParams params(32);//max search depth


    vecQuery = { 3, 4};
    kdtree.knnSearch(vecQuery, vecIndex, vecDist, queryNum, params);

    cout &lt;&lt; &quot;vecDist: &quot; &lt;&lt; endl;
    for (auto&amp;x : vecDist)
        cout &lt;&lt; x &lt;&lt; &quot; &quot;;
    cout &lt;&lt; endl;

    cout &lt;&lt; &quot;vecIndex: &quot; &lt;&lt; endl;
    for (auto&amp;x : vecIndex)
        cout &lt;&lt; x &lt;&lt; &quot; &quot;;

    return 0;
}
</code></pre>

<p>There is some points you should be careful:
1. FLANN in OpenCV does not support <code>double</code>
2. In this part, the type of query point is <code>vector&lt;float&gt;</code>，if you are using <code>cv::Mat(features[0])</code>, there will be a segmentation fault.
3. You need to maintain the input array all the time. So if you want to separate the building process and searching process, you need to maintain a shared matrix cloned from the origin matrix. OPLib uses a member(<code>input_array</code>) in class. 
4. <code>knnSearch</code> won't return any value, and you need to do a <code>resize(k)</code> for indices and distances array before searching. In <code>radiusSearch</code>, you don't have to resize the indices and distances array. <code>radiusSearch</code> will reture a number of searched points. You need to use the retured value to iterate the indices and distance array rather than <code>indices.size()</code>, because <code>indices.size()</code> is equal to <code>max_points</code> you set before, which is the maximum number of points you want to search.</p>
<p>Anyway, you have no needs to worry about these problems in OPLib. In <code>OPLib</code>, <code>KDTree</code> is very simple to use. It is a template class, that is, you need to specify the dimensions of the data placed in the tree. When building the tree, directly input the <code>PointList</code> series defined in <code>geometry.h</code> (essentially the <code>vector</code> of the <code>Eigen</code> vector), which can be a dynamic vector array or a static vector array. If it is a dynamic vector array, the dimension of the dynamic vector needs to be equal to the dimension of the template. In addition, searching through <code>RadiusSearch</code> and <code>KnnSearch</code> can also be directly based on the vector of <code>Eigen</code>, and OPLib doesn't have any assumption about the <code>indices</code> array and <code>distances</code> array.</p>
<h4 id="nanoflann">nanoflann</h4>
<p><a href="https://github.com/jlblancoc/nanoflann">nanoflann</a> is a very lightweight C++11 library, with only one hpp file. Compared with the implementation of OpenCV, nanoflann is more efficient and occupies less memory. In nanoflann, you need to declare a class for each kinds of points(such as 2D or 3D points) that needs to be searched, which contains certain functions. In OPLib, there is no need to do this.  Nanoflann's <code>radiusSearch</code> cannot specify <code>max_neighbors</code>, which means it will find all points within the radius. This is not necessary in some cases and can cause waste of computing resources. OPLib modified the source code of <code>nanoflann</code> to get this feature (all points will be searched when <code>max_neighbors</code>=0).</p>
<p>The KDTree based on nanoflann implementation has the same usage of KDTree based on OpenCV. Additionally, it supports indices of <code>std::vector&lt;size_t&gt;</code>.</p>
<pre><code class="cpp">    class SearchParameter
    {
        public:
        //kdtree parameter
        SearchParameter(int _checks = 256, 
            float _eps = 1e-8, bool _sorted = true)
        {
            checks = _checks;
            eps = _eps;
            sorted = _sorted;
        }
        //the indices array is sorted based on the distances
        bool sorted = true;
        //EPS
        float eps = 1e-8;
        //Max search depth
        int checks = 256;


    };
    template&lt;int T = 3&gt;
    class KDTree
    {
        public:
        KDTree(int _trees = 4)
        {
            trees = 4;
        }
        //To build KDTree from a set of high-dimensional vectors, you can choose to use a dynamic vector vector or a static vector vector
        void BuildTree(const geometry::PointXList &amp;points);

        void BuildTree(const geometry::PointList&lt;T&gt; &amp;points);
        //strange rules in opencv flann: 
        //when you do knnsearch, you need to resize(k) at beginning.
        //when you do radius search, you need to get the returned points_count and do a resize for the results.
        //search points within radius for a dynamic vector or static vector 
        void RadiusSearch(const geometry::VectorX &amp;point, std::vector&lt;int&gt; &amp;indices, 
            std::vector&lt;float &gt; &amp;dists, double radius, int max_result, 
            const SearchParameter &amp;sp = SearchParameter());
        void RadiusSearch(const geometry::Vector&lt;T&gt; &amp;point, std::vector&lt;int&gt; &amp;indices, 
            std::vector&lt;float &gt; &amp;dists, double radius, int max_result, 
            const SearchParameter sp = SearchParameter());
        //search the k nearest points for a dynamic vector or static vector 
        void KnnSearch(const geometry::VectorX &amp;point, std::vector&lt;int&gt; &amp;indices, 
            std::vector&lt;float &gt; &amp;dists, int k, 
            const SearchParameter &amp;sp = SearchParameter());
        void KnnSearch(const geometry::Vector&lt;T&gt; &amp;point, std::vector&lt;int&gt; &amp;indices, 
            std::vector&lt;float &gt; &amp;dists, int k, 
            const SearchParameter &amp;sp = SearchParameter());

#if NANO_IMPLEMENTATION
        //only nanoflann based KDTree supports
        void RadiusSearch(const geometry::VectorX &amp;point, std::vector&lt;size_t&gt; &amp;indices, 
            std::vector&lt;float &gt; &amp;dists, double radius, int max_result, 
            const SearchParameter &amp;sp = SearchParameter());
        void RadiusSearch(const geometry::Vector&lt;T&gt; &amp;point, std::vector&lt;size_t&gt; &amp;indices, 
            std::vector&lt;float &gt; &amp;dists, double radius, int max_result, 
            const SearchParameter sp = SearchParameter());
        //search the k nearest points for a dynamic vector or static vector 
        void KnnSearch(const geometry::VectorX &amp;point, std::vector&lt;size_t&gt; &amp;indices, 
            std::vector&lt;float &gt; &amp;dists, int k, 
            const SearchParameter &amp;sp = SearchParameter());
        void KnnSearch(const geometry::Vector&lt;T&gt; &amp;point, std::vector&lt;size_t&gt; &amp;indices, 
            std::vector&lt;float &gt; &amp;dists, int k, 
            const SearchParameter &amp;sp = SearchParameter());
#endif
    };
</code></pre>

<p>You can view <code>example/GetLabelUsingKDTree.cpp</code> to better understand how to use KDTree in OPLib. The input is two models: original model (without semantic information) and reference model (with semantic information). By finding the closest point through KDTree, we can obtain the original model's semantic labels.</p>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../odometry/" class="btn btn-neutral float-right" title="Odometry">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="../camera/" class="btn btn-neutral" title="Camera"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
          <a href="https://github.com/MyEvolution/FCLib" class="fa fa-github" style="float: left; color: #fcfcfc"> GitHub</a>
      
      
        <span><a href="../camera/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="../odometry/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>
    <script>var base_url = '../..';</script>
    <script src="../../js/theme.js" defer></script>
      <script src="../../javascripts/config.js" defer></script>
      <script src="https://polyfill.io/v3/polyfill.min.js?features=es6" defer></script>
      <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" defer></script>
      <script src="../../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
