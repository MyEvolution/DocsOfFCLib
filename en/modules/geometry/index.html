<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  
  <link rel="shortcut icon" href="../../img/favicon.ico">
  <title>Geometry - FCLib</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700" />

  <link rel="stylesheet" href="../../css/theme.css" />
  <link rel="stylesheet" href="../../css/theme_extra.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" />
  
  <script>
    // Current page data
    var mkdocs_page_name = "Geometry";
    var mkdocs_page_input_path = "modules\\geometry.md";
    var mkdocs_page_url = null;
  </script>
  
  <script src="../../js/jquery-2.1.1.min.js" defer></script>
  <script src="../../js/modernizr-2.8.3.min.js" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
        <a href="../.." class="icon icon-home"> FCLib</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
                <p class="caption"><span class="caption-text">Overview</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../..">Brief Introduction</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../rules/">Some Rules</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">Modules</span></p>
                <ul class="current">
                    <li class="toctree-l1"><a class="reference internal" href="../camera/">Camera</a>
                    </li>
                    <li class="toctree-l1 current"><a class="reference internal current" href="./">Geometry</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#geometryh">Geometry.h</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#geometry2dh">Geometry2d.h</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#pointcloudh">PointCloud.h</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#trianglemeshh">TriangleMesh.h</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#ransach">Ransac.h</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#rgbdframeh">RGBDFrame.h</a>
    </li>
    </ul>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../odometry/">Odometry</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../lcdetection/">Loop Closure Detection</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../registration/">Point Cloud Registration</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../optimization/">Optimization</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../integration/">Generate Model</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../visualization/">Visualization</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../algorithm/">Some Algorithms</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../tool/">Other Useful Tools</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../examples/">Examples</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">Others</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../thanksto/">Acknowledgments</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../about/">About Author</a>
                    </li>
                </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../..">FCLib</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../..">Docs</a> &raquo;</li>
    
      
        
          <li>Modules &raquo;</li>
        
      
    
    <li>Geometry</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h2 id="geometry">Geometry</h2>
<p>The geometry module is a foundation of the entire system. It defines some very basic data structures and implements basic operations and algorithms, including points, transformation matrix, the conversion between Lie groups and Lie algebras (SE(3), se(3)) etc., as well as the definition and implementation of common data structures such as point clouds, triangular mesh and related algorithms.</p>
<h3 id="geometryh">Geometry.h</h3>
<p>In <code>Geometry.h</code>, the first thing you shuold notice is that:</p>
<pre><code class="cpp">typedef float scalar; 
</code></pre>

<p>By default, <code>float</code> is used as the scalar type, so the format of point clouds, matrix, etc. are all single-precision, and the floating-point number precision used by the entire library can be changed here.</p>
<pre><code class="cpp">typedef Vector6 Se3;
typedef Matrix4 SE3;
</code></pre>

<p>Lie group Lie algebras are defined as <code>SE3</code> and <code>Se3</code>, which are four-dimensional square matrix and six-dimensional matrix, respectively, through the function:</p>
<pre><code class="cpp">Matrix4 Se3ToSE3(const Vector6 &amp;input);
Vector6 SE3ToSe3(const Matrix4 &amp;input);
</code></pre>

<p>you can do the conversion. These functions are implemented based on <code>Sophus</code> library(In Open3D, the mutual conversion from a 6-dimensional vector to a 4-dimensional square matrix is completely unchanged for the translation part, but from the mathematical derivation, there is a slight difference between the two, so the <code>Sophus</code> library should be more accurate).
<img alt="" src="../../img/lie.jpg" /></p>
<pre><code class="cpp">struct VoxelGridHasher;
struct PixelGridHasher;
</code></pre>

<p>The above two are hash functions for three-dimensional and two-dimensional integer vectors, and spatial hashing is a very efficient data structure.</p>
<pre><code class="cpp">std::tuple&lt;Point3, double, double&gt; FitPlane(const Point3List &amp; _points);
std::tuple&lt;Vector2, double, double&gt; FitLine(const Point2List &amp; _points);
</code></pre>

<p>The above functions are used to fit a set of 3D point planes and 2D point lines. For example, in a three-dimensional coordinate system, the parametric equation of a plane is: <span class="arithmatex">\(ax+by+cz+d = 0\)</span>, where <span class="arithmatex">\(n=\{ a, b, c\)^T\)</span> is the normal vector of the plane. The return value type of the above function is <code>std::tuple</code>, where the first term is the normal vector, and the second is <span class="arithmatex">\(d\)</span>. The third one is a ratio of the second largest singular value to the largest singular value (using SVD to fit a plane or a straight line, you can get singular values), which can be used as an indicator of the error between the original points and the fitted plane. If all points are in On the plane, the value is 0. That is, the better the plane fits, the smaller the value.</p>
<p>In <code>Geometry.h</code>, some other aliases are also defined. These aliases are defined for easy-understanding. Some basic knowledges of Feature Matching, etc. is needed to understand the meaning.</p>
<h3 id="geometry2dh">Geometry2d.h</h3>
<p><code>Geometry2d.h</code> implements some geometric algorithms on 2d, mainly to calculate some very basic content of geometry. This part is written for <code>DCEL</code> (doubly connected edge list) in <code>Algorithm</code>. The main functions in this part are:</p>
<pre><code class="cpp">//Check if a point is inside a convex polygon
int CheckPointInConvexPoly(const geometry::Point2List &amp;points, const Point2 &amp;p);
//Calculate the area of a convex polygon
float ComputeAreaConvexPoly(const Point2List &amp;points);
</code></pre>

<h3 id="pointcloudh">PointCloud.h</h3>
<p><code>PointCloud.h</code> implements some point cloud-related data structures and algorithms. The point cloud contains points, colors, and normals (the latter two are optional). The related algorithms include point cloud downsampling, normal vector estimation, and so on. Some basic member functions are listed below:</p>
<pre><code class="cpp">//Read PCD from PLY file
void LoadFromPLY(const std::string &amp;filename);
//Read PCD from OBJ file
void LoadFromOBJ(const std::string &amp;filename);
//Read PCD from color and depth
void LoadFromRGBD(const cv::Mat &amp;rgb, const cv::Mat &amp; depth, const camera::PinholeCamera &amp;camera );
void LoadFromRGBD(const RGBDFrame &amp;rbgd, const camera::PinholeCamera &amp;camera );
//Estimate the normal vector by fitting a plane to the surrounding points of a certain point. 
//`radius` represents the search radius, and `knn` represents the number of fitting points
void EstimateNormals(float radius = 0.1, int knn = 30);
//Transform pcd
void Transform(const TransformationMatrix &amp;T);
//Down sample 
std::shared_ptr&lt;PointCloud&gt; DownSample(double grid_len);
//Write pcd to PLY file
bool WriteToPLY(const std::string &amp;fileName) const;
//Write pcd to OBJ file
bool WriteToOBJ(const std::string &amp;fileName) const;
//Merge this pcd with another one
void MergePCD(const PointCloud &amp; another_pcd);
</code></pre>

<h4 id="trianglemeshh">TriangleMesh.h</h4>
<p>TriangleMesh defines the triangular mesh data structures and related algorithms. The biggest difference between a triangular mesh and a point cloud is that there are edges and faces in triangle mesh. In the triangular mesh, each face is a triangle and consists of 3 points. Therefore, there is also a face table in the triangular mesh, which stores the indexes of the 3 points of each triangle. The currently implemented grid does not contain textures.</p>
<pre><code class="cpp">//Read mesh from PLY file
void LoadFromPLY(const std::string &amp;filename);
// Read Mesh from OBJ file
void LoadFromOBJ(const std::string &amp;filename);
/*
Calculating the normal vector, the normal vector of the triangular grid is easier to estimate compared to the normal vector of the pcd.
First of all, the triangular mesh already has a face, and you can directly find the plane based on the three points to get the normal vector of the face.
Then, we only need to perform a weighted average of the normal vectors of all the faces connected to the point to get the normal vector of a point.
*/
void ComputeNormals(float radius = 0.1, int knn = 30);
//Transform the mesh
void Transform(const TransformationMatrix &amp;T);
//Write mesh to PLY file
bool WriteToPLY(const std::string &amp;fileName) const;
//Write mesh to OBJ file
bool WriteToOBJ(const std::string &amp;fileName) const;
//Simplify mesh with edge collapse based on quadric error
std::shared_ptr&lt;geometry::TriangleMesh&gt; QuadricSimplify(int target_num) const;
//Voxel-based uniform grid simplification, similar to point cloud downsampling
std::shared_ptr&lt;geometry::TriangleMesh&gt; ClusteringSimplify(float grid_len) const;
//Remove fragments whose connected points is less than a threshold
std::shared_ptr&lt;geometry::TriangleMesh&gt; Prune(int min_points) const;
</code></pre>

<p>For details of quadric simplification, refer to:<code>related_paper/quadrics.pdf</code>.</p>
<p>Comparison of simplification: <a href="../../examples/#_2">Simplification</a></p>
<h3 id="ransach">Ransac.h</h3>
<p><code>Ransac.h</code> mainly implements two specific algorithms that use ransac, based on a basic Ransac framework <a href="https://github.com/drsrinathsridhar/GRANSAC">GRANSAC</a>. The advantage of Ransac is that it will randomly extract some points are used to find a certain transformation or model, so that outliers can be largely excluded. For example, when fitting a plane, if you use the <code>FitPlane</code> in <code>Geometry.h</code> to directly fit, then the outlier will have a great impact on the result. And using Ransac can get better results.</p>
<pre><code class="cpp">//Use Ransac to estimate the relative transformation
TransformationMatrix EstimateRigidTransformationRANSAC(const PointCorrespondenceSet &amp;correspondence_set,
    PointCorrespondenceSet &amp; inliers, std::vector&lt;int&gt; &amp;inlier_ids, int max_iteration = 2000, float threshold = 0.1);
//Use Ransac to fit plane
std::tuple&lt;geometry::Point3, double, double&gt; FitPlaneRANSAC(const Point3List &amp;points, 
    Point3List &amp; inliers, std::vector&lt;int&gt; &amp;inlier_ids, int max_iteration = 2000, float threshold = 0.05);
</code></pre>

<p>You can get the inlies and corresponding indices using above function.</p>
<h3 id="rgbdframeh">RGBDFrame.h</h3>
<p><code>RGBDFrame.h</code> defines the RGBDFrame data structure, which integrates the depth map and the color map, and can simplify the calling process. This data structure is mainly used to serve an RGBD SLAM system. It can save some of the extracted features, point cloud and so on, which are needed for tracking. When building an RGBD SLAM, for efficiency these contents do not need to be recalculated. <code>Release()</code> is used to release all saved content.</p>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../odometry/" class="btn btn-neutral float-right" title="Odometry">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="../camera/" class="btn btn-neutral" title="Camera"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
          <a href="https://github.com/MyEvolution/FCLib" class="fa fa-github" style="float: left; color: #fcfcfc"> GitHub</a>
      
      
        <span><a href="../camera/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="../odometry/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>
    <script>var base_url = '../..';</script>
    <script src="../../js/theme.js" defer></script>
      <script src="../../javascripts/config.js" defer></script>
      <script src="https://polyfill.io/v3/polyfill.min.js?features=es6" defer></script>
      <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" defer></script>
      <script src="../../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
